1. long zfunction(long param)

Clear the 9th to 17th bits, counting from right and starting with 0, shift the parameter param by 8 bits to the right, and then ﬁll the left most bits with 1. For example, the input parameter 0xaabbccdd should generate a return value of 0xffaab800. You can assume that the size of long is 4 bytes. The code for this function should be entirely written in x86 assembly. You should not use inline assembly, (i.e., do not use asm(???)). To investigate the assembly code generated by the compiler, you can use the tool objdump d <___.o> to disassemble an object ﬁle. The object ﬁles reside in the /compile directory within the main Xinu directory. You can also see some of the *.S ﬁles in the /sys directory for reference.

2. void printsegaddress()

Print the addresses and their contents indicating the end of the text, data, and BSS segments of the current process. You can refer to the manual page for "etext". Also print the 4-byte contents (in hexadecimal) preceding and after those addresses. This function can be written in C.

3. void printtos()

Print the address and their contents of the top of the run-time stack for whichever process you are currently in, right before and right after you get into the printos() function call. In addition, print the address and their contents of upto four stack locations below the top of the stack (the four or fewer items that have been the most recently pushed, if any). Remember that stack elements are 32 bits wide, and be careful to perform pointer arithmetic correctly. Also note that there are local variables and arguments on the stack, among other things. See the hints given for #4 below, especially on stacktrace.c and proc.h. Your function can be written entirely in C, or you can use in-line assembly if you prefer. This wiki page can be helpful.

4. void printprocstks(int priority)

For each existing process with larger priority than the parameter, print the stack base, stack size, stacklimit, and stack pointer. Also, for each process, include the process name, the process id and the process priority.

To help you do this, please look into proc.h in the h/ directory. Note the proctab[] array that holds all processes. Also, note that the pesp member of the pentry structure holds the saved stack pointer. Therefore, the currently executing process has a stack pointer that is different from the value of this variable. In order to help you get the stack pointer of the currently executing process, carefully study the stacktrace.c ﬁle in the sys/ directory. The register %esp holds the current stack pointer. You can use in-line assembly(i.e., asm("...")) to do this part.

5. void printsyscallsummary()

Print the summary of the system calls which have been invoked for each process. This task is loosely based on the functionality of LTTng. There are 43 system calls declared. Please look into kernel.h in the h/ directory to see all declared system calls. However, only 27 system calls are implemented in this XINU version. The implementation of these 27 system calls are in the sys/ directory. You are asked to print the frequency (how many times each system call type is invoked) and the average execution time (how long it takes to execute each system call type in average) of these 27 system calls for each process. In order to do this, you will need to modify the implementation of these 27 types of system calls to trace them whenever they are invoked. To measure the time, XINU provides a global variable named ctr1000 to track the time (in milliseconds) passed by since the system starts. Please look into sys/clkinit.c and sys/clkint.S to see the details.

You will also need to implement two other functions:

void syscallsummary_start(): to start tracing the system calls. All the system calls are invoked after calling this function (and before calling syscallsummary_stop()) will be presented in the system call summary.

void syscallsummary_stop(): to stop tracing the system calls.

In other words, these two functions determine the duration in which the system calls are traced.
